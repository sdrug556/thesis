'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var smob = require('smob');

var Parameter = /* @__PURE__ */ ((Parameter2) => {
  Parameter2["FILTERS"] = "filters";
  Parameter2["FIELDS"] = "fields";
  Parameter2["PAGINATION"] = "pagination";
  Parameter2["RELATIONS"] = "relations";
  Parameter2["SORT"] = "sort";
  return Parameter2;
})(Parameter || {});
var URLParameter = /* @__PURE__ */ ((URLParameter2) => {
  URLParameter2["FILTERS"] = "filter";
  URLParameter2["FIELDS"] = "fields";
  URLParameter2["PAGINATION"] = "page";
  URLParameter2["RELATIONS"] = "include";
  URLParameter2["SORT"] = "sort";
  return URLParameter2;
})(URLParameter || {});
const DEFAULT_ID = "__DEFAULT__";

function buildKeyPath(key, prefix) {
  if (typeof prefix === "string") {
    return `${prefix}.${key}`;
  }
  return key;
}
function flattenToKeyPathArray(input, options, prefix) {
  options = options || {};
  const output = [];
  if (options.transformer) {
    const result = options.transformer(input, output, prefix);
    if (typeof result !== "undefined" && !!result) {
      return output;
    }
  }
  if (Array.isArray(input)) {
    for (let i = 0; i < input.length; i++) {
      if (options.transformer) {
        const result = options.transformer(input[i], output, prefix);
        if (typeof result !== "undefined" && !!result) {
          return output;
        }
      }
      if (Array.isArray(input[i])) {
        for (let j = 0; j < input[i].length; j++) {
          const key = buildKeyPath(input[i][j], prefix);
          output.push(key);
        }
        continue;
      }
      if (typeof input[i] === "string") {
        output.push(buildKeyPath(input[i], prefix));
        continue;
      }
      if (typeof input[i] === "object") {
        const keys = Object.keys(input[i]);
        for (let j = 0; j < keys.length; j++) {
          const value = buildKeyPath(keys[j], prefix);
          const data = flattenToKeyPathArray(input[i][keys[j]], options, value);
          if (data.length === 0) {
            output.push(value);
          } else {
            output.push(...data);
          }
        }
      }
    }
    return output;
  }
  if (typeof input === "object" && input !== null) {
    const keys = Object.keys(input);
    for (let i = 0; i < keys.length; i++) {
      const value = buildKeyPath(keys[i], prefix);
      const data = flattenToKeyPathArray(input[keys[i]], options, value);
      if (data.length === 0) {
        output.push(value);
      } else {
        output.push(...data);
      }
    }
    return output;
  }
  if (typeof input === "string") {
    const value = buildKeyPath(input, prefix);
    output.push(value);
    return output;
  }
  return output;
}
function groupArrayByKeyPath(input) {
  const pathItems = {};
  for (let i = 0; i < input.length; i++) {
    const parts = input[i].split(".");
    let key;
    let name;
    if (parts.length === 1) {
      key = DEFAULT_ID;
      name = input[i];
    } else {
      name = parts.pop();
      key = parts.join(".");
    }
    if (!Object.prototype.hasOwnProperty.call(pathItems, key)) {
      pathItems[key] = [];
    }
    pathItems[key].push(name);
  }
  return pathItems;
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function flattenNestedObject(data, options, prefixParts) {
  options = options || {};
  prefixParts = prefixParts || [];
  let output = {};
  if (options.transformer) {
    const result = options.transformer(data, output, prefixParts.join("."));
    if (typeof result !== "undefined" && !!result) {
      return output;
    }
  }
  const keys = Object.keys(data);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (options.transformer) {
      const result = options.transformer(data[key], output, [...prefixParts, key].join("."));
      if (typeof result !== "undefined" && !!result) {
        continue;
      }
    }
    if (typeof data[key] === "object" && data[key]) {
      output = { ...output, ...flattenNestedObject(data[key], options, [...prefixParts, key]) };
      continue;
    }
    const destinationKey = [...prefixParts, key].join(".");
    if (typeof data[key] === "boolean" || typeof data[key] === "string" || typeof data[key] === "number" || typeof data[key] === "undefined" || data[key] === null || Array.isArray(data[key])) {
      output[destinationKey] = data[key];
    }
  }
  return output;
}

function applyMapping(name, map, onlyKey) {
  if (typeof map === "undefined") {
    return name;
  }
  let parts = name.split(".");
  const output = [];
  let run = true;
  while (run) {
    const value = parts.shift();
    if (typeof value === "undefined") {
      run = false;
      break;
    }
    if (hasOwnProperty(map, value)) {
      output.push(map[value]);
    } else {
      let found = false;
      const rest = [];
      const copy = [...parts];
      while (copy.length > 0) {
        const key = [value, ...copy].join(".");
        if (hasOwnProperty(map, key)) {
          output.push(map[key]);
          found = true;
          break;
        } else {
          const last = copy.pop();
          if (last) {
            rest.unshift(last);
          }
        }
      }
      if (found) {
        parts = rest;
      } else {
        output.push(value);
      }
    }
  }
  if (onlyKey) {
    return output.pop();
  }
  return output.join(".");
}

function getFieldDetails(field) {
  const parts = field.split(".");
  return {
    name: parts.pop(),
    path: parts.length > 0 ? parts.join(".") : void 0
  };
}

function isFieldNonRelational(field) {
  const details = typeof field === "string" ? getFieldDetails(field) : field;
  return typeof details.path === "undefined";
}
function isFieldPathAllowedByRelations(field, includes) {
  if (typeof includes === "undefined") {
    return true;
  }
  const details = typeof field === "string" ? getFieldDetails(field) : field;
  if (typeof details.path === "undefined") {
    return true;
  }
  return includes.some(
    (include) => include.key === details.path
  );
}
function buildFieldWithPath(field, path) {
  const details = typeof field === "string" ? getFieldDetails(field) : field;
  return details.path || path ? `${details.path || path}.${details.name}` : details.name;
}

function buildURLQueryString(data, withQuestionMark = true) {
  if (typeof data === "undefined" || data === null)
    return "";
  if (typeof data === "string")
    return data;
  const query = [];
  const keys = Object.keys(data);
  for (let i = 0; i < keys.length; i++) {
    if (Object.prototype.hasOwnProperty.call(data, keys[i])) {
      let value = data[keys[i]];
      if (value && typeof value === "object" && value.constructor === Array) {
        value = value.join(",");
      }
      if (value && typeof value === "object" && value.constructor === Object) {
        const valueKeys = Object.keys(value);
        for (let j = 0; j < valueKeys.length; j++) {
          let v = value[valueKeys[j]];
          if (v && typeof v === "object" && v.constructor === Array) {
            v = v.join(",");
          }
          query.push(`${encodeURIComponent(`${keys[i]}[${valueKeys[j]}]`)}=${encodeURIComponent(v)}`);
        }
        continue;
      }
      query.push(`${encodeURIComponent(keys[i])}=${encodeURIComponent(value)}`);
    }
  }
  return (withQuestionMark ? "?" : "") + query.join("&");
}

function buildQueryFields(input) {
  if (typeof input === "undefined") {
    return [];
  }
  const data = groupArrayByKeyPath(flattenToKeyPathArray(input));
  const keys = Object.keys(data);
  if (keys.length === 1) {
    return data[keys[0]];
  }
  return data;
}
function mergeQueryFields(target, source) {
  if (Array.isArray(target)) {
    target = groupArrayByKeyPath(target);
  }
  if (Array.isArray(source)) {
    source = groupArrayByKeyPath(source);
  }
  const merge = smob.createMerger({
    array: true,
    arrayDistinct: true
  });
  const data = merge({}, target, source);
  const keys = Object.keys(data);
  if (keys.length === 1) {
    return data[keys[0]];
  }
  return data;
}

var FieldOperator = /* @__PURE__ */ ((FieldOperator2) => {
  FieldOperator2["INCLUDE"] = "+";
  FieldOperator2["EXCLUDE"] = "-";
  return FieldOperator2;
})(FieldOperator || {});

function flattenParseAllowedOption(input) {
  return flattenToKeyPathArray(input);
}
function isPathCoveredByParseAllowedOption(input, path) {
  const paths = Array.isArray(path) ? path : [path];
  const items = flattenToKeyPathArray(input);
  for (let i = 0; i < items.length; i++) {
    if (paths.indexOf(items[i]) !== -1) {
      return true;
    }
  }
  return false;
}

function buildFieldDomainRecords(data) {
  if (typeof data === "undefined") {
    return {};
  }
  let domainFields = {};
  if (Array.isArray(data)) {
    domainFields[DEFAULT_ID] = data;
  } else {
    domainFields = data;
  }
  return domainFields;
}

function removeFieldInputOperator(field) {
  return field.substring(0, 1) === FieldOperator.INCLUDE || field.substring(0, 1) === FieldOperator.EXCLUDE ? field.substring(1) : field;
}
function transformFieldsInput(fields) {
  const output = {
    default: [],
    included: [],
    excluded: []
  };
  for (let i = 0; i < fields.length; i++) {
    let operator;
    if (fields[i].substring(0, 1) === FieldOperator.INCLUDE) {
      operator = FieldOperator.INCLUDE;
    } else if (fields[i].substring(0, 1) === FieldOperator.EXCLUDE) {
      operator = FieldOperator.EXCLUDE;
    }
    if (operator) {
      fields[i] = fields[i].substring(1);
      switch (operator) {
        case FieldOperator.INCLUDE: {
          output.included.push(fields[i]);
          break;
        }
        case FieldOperator.EXCLUDE: {
          output.excluded.push(fields[i]);
          break;
        }
      }
    } else {
      output.default.push(fields[i]);
    }
  }
  return output;
}
function parseFieldsInput(data) {
  const valuePrototype = Object.prototype.toString.call(data);
  if (valuePrototype !== "[object Array]" && valuePrototype !== "[object String]") {
    return [];
  }
  let fieldsArr = [];
  if (valuePrototype === "[object String]") {
    fieldsArr = data.split(",");
  }
  if (valuePrototype === "[object Array]") {
    fieldsArr = data.filter((val) => typeof val === "string");
  }
  return fieldsArr;
}

function isValidFieldName(input) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/gu.test(input);
}

function buildReverseRecord(record) {
  const keys = Object.keys(record);
  const output = {};
  for (let i = 0; i < keys.length; i++) {
    output[record[keys[i]]] = keys[i];
  }
  return output;
}
function parseQueryFields(data, options) {
  options = options || {};
  const defaultDomainFields = groupArrayByKeyPath(
    flattenParseAllowedOption(options.default)
  );
  const allowedDomainFields = groupArrayByKeyPath(
    flattenParseAllowedOption(options.allowed)
  );
  const domainFields = smob.merge(
    {},
    defaultDomainFields,
    allowedDomainFields
  );
  let keys = Object.keys(domainFields);
  if ((typeof options.default !== "undefined" || typeof options.allowed !== "undefined") && keys.length === 0) {
    return [];
  }
  const prototype = Object.prototype.toString.call(data);
  if (prototype !== "[object Object]" && prototype !== "[object Array]" && prototype !== "[object String]") {
    data = { [DEFAULT_ID]: [] };
  }
  if (prototype === "[object String]") {
    data = { [DEFAULT_ID]: data };
  }
  if (prototype === "[object Array]") {
    data = { [DEFAULT_ID]: data };
  }
  options.mapping = options.mapping || {};
  const reverseMapping = buildReverseRecord(options.mapping);
  if (keys.length === 0) {
    keys = Object.keys(data);
  }
  const output = [];
  for (let i = 0; i < keys.length; i++) {
    const path = keys[i];
    if (!isFieldPathAllowedByRelations({ path }, options.relations) && path !== DEFAULT_ID) {
      continue;
    }
    let fields = [];
    if (hasOwnProperty(data, path)) {
      fields = parseFieldsInput(data[path]);
    } else if (hasOwnProperty(reverseMapping, path)) {
      if (hasOwnProperty(data, reverseMapping[path])) {
        fields = parseFieldsInput(data[reverseMapping[path]]);
      }
    }
    let transformed = {
      default: [],
      included: [],
      excluded: []
    };
    if (fields.length > 0) {
      for (let j = 0; j < fields.length; j++) {
        fields[j] = applyMapping(
          buildFieldWithPath({ name: fields[j], path }),
          options.mapping,
          true
        );
      }
      if (hasOwnProperty(domainFields, path)) {
        fields = fields.filter((field) => domainFields[path].indexOf(
          removeFieldInputOperator(field)
        ) !== -1);
      } else {
        fields = fields.filter((field) => isValidFieldName(removeFieldInputOperator(field)));
      }
      transformed = transformFieldsInput(
        fields
      );
    }
    if (transformed.default.length === 0 && hasOwnProperty(defaultDomainFields, path)) {
      transformed.default = defaultDomainFields[path];
    }
    if (transformed.included.length === 0 && transformed.default.length === 0 && hasOwnProperty(allowedDomainFields, path)) {
      transformed.default = allowedDomainFields[path];
    }
    transformed.default = Array.from(/* @__PURE__ */ new Set([
      ...transformed.default,
      ...transformed.included
    ]));
    for (let j = 0; j < transformed.excluded.length; j++) {
      const index = transformed.default.indexOf(transformed.excluded[j]);
      if (index !== -1) {
        transformed.default.splice(index, 1);
      }
    }
    if (transformed.default.length > 0) {
      for (let j = 0; j < transformed.default.length; j++) {
        let destPath;
        if (path !== DEFAULT_ID) {
          destPath = path;
        } else if (options.defaultPath) {
          destPath = options.defaultPath;
        }
        output.push({
          key: transformed.default[j],
          ...destPath ? { path: destPath } : {}
        });
      }
    }
  }
  return output;
}

var FilterComparisonOperator = /* @__PURE__ */ ((FilterComparisonOperator2) => {
  FilterComparisonOperator2["EQUAL"] = "$eq";
  FilterComparisonOperator2["NOT_EQUAL"] = "$ne";
  FilterComparisonOperator2["LIKE"] = "$l";
  FilterComparisonOperator2["NOT_LIKE"] = "$nl";
  FilterComparisonOperator2["LESS_THAN_EQUAL"] = "$lte";
  FilterComparisonOperator2["LESS_THAN"] = "$lt";
  FilterComparisonOperator2["GREATER_THAN_EQUAL"] = "$gte";
  FilterComparisonOperator2["GREATER_THAN"] = "$gt";
  FilterComparisonOperator2["IN"] = "$in";
  FilterComparisonOperator2["NOT_IN"] = "$nin";
  return FilterComparisonOperator2;
})(FilterComparisonOperator || {});
var FilterInputOperatorValue = /* @__PURE__ */ ((FilterInputOperatorValue2) => {
  FilterInputOperatorValue2["NEGATION"] = "!";
  FilterInputOperatorValue2["LIKE"] = "~";
  FilterInputOperatorValue2["LESS_THAN_EQUAL"] = "<=";
  FilterInputOperatorValue2["LESS_THAN"] = "<";
  FilterInputOperatorValue2["MORE_THAN_EQUAL"] = ">=";
  FilterInputOperatorValue2["MORE_THAN"] = ">";
  FilterInputOperatorValue2["IN"] = ",";
  return FilterInputOperatorValue2;
})(FilterInputOperatorValue || {});

function buildQueryFilters(data) {
  if (typeof data === "undefined") {
    return {};
  }
  return flattenNestedObject(data, {
    transformer: (input, output, key) => {
      if (typeof input === "undefined") {
        output[key] = null;
        return true;
      }
      if (Array.isArray(input)) {
        const data2 = [];
        for (let i = 0; i < input.length; i++) {
          if (input[i] === null) {
            input[i] = "null";
          }
          if (typeof input[i] === "number") {
            input[i] = `${input[i]}`;
          }
          if (typeof input[i] === "string") {
            data2.push(input[i]);
          }
        }
        output[key] = data2.join(",");
        return true;
      }
      return void 0;
    }
  });
}
function mergeQueryFilters(target, source) {
  return smob.merge({}, target || {}, source || {});
}

function transformFilterValue(input) {
  if (typeof input === "string") {
    input = input.trim();
    const lower = input.toLowerCase();
    if (lower === "true") {
      return true;
    }
    if (lower === "false") {
      return false;
    }
    if (lower === "null") {
      return null;
    }
    if (input.length === 0) {
      return input;
    }
    const num = Number(input);
    if (!Number.isNaN(num)) {
      return num;
    }
    const parts = input.split(",");
    if (parts.length > 1) {
      return transformFilterValue(parts);
    }
  }
  if (Array.isArray(input)) {
    for (let i = 0; i < input.length; i++) {
      input[i] = transformFilterValue(input[i]);
    }
    return input.filter((n) => n === 0 || n === null || !!n);
  }
  if (typeof input === "undefined" || input === null) {
    return null;
  }
  return input;
}

function matchOperator(key, value, position) {
  if (typeof value === "string") {
    switch (position) {
      case "start": {
        if (value.substring(0, key.length) === key) {
          return value.substring(key.length);
        }
        break;
      }
      case "end": {
        if (value.substring(0 - key.length) === key) {
          return value.substring(0, value.length - key.length - 1);
        }
        break;
      }
    }
    return void 0;
  }
  if (Array.isArray(value)) {
    let match = false;
    for (let i = 0; i < value.length; i++) {
      const output = matchOperator(key, value[i], position);
      if (typeof output !== "undefined") {
        match = true;
        value[i] = output;
      }
    }
    if (match) {
      return value;
    }
  }
  return void 0;
}
function parseFilterValue(input) {
  if (typeof input === "string" && input.includes(FilterInputOperatorValue.IN)) {
    input = input.split(FilterInputOperatorValue.IN);
  }
  let negation = false;
  let value = matchOperator(FilterInputOperatorValue.NEGATION, input, "start");
  if (typeof value !== "undefined") {
    negation = true;
    input = value;
  }
  if (Array.isArray(input)) {
    return {
      value: input,
      operator: negation ? FilterComparisonOperator.NOT_IN : FilterComparisonOperator.IN
    };
  }
  value = matchOperator(FilterInputOperatorValue.LIKE, input, "start");
  if (typeof value !== "undefined") {
    return {
      value,
      operator: negation ? FilterComparisonOperator.NOT_LIKE : FilterComparisonOperator.LIKE
    };
  }
  value = matchOperator(FilterInputOperatorValue.LESS_THAN_EQUAL, input, "start");
  if (typeof value !== "undefined") {
    return {
      value,
      operator: FilterComparisonOperator.LESS_THAN_EQUAL
    };
  }
  value = matchOperator(FilterInputOperatorValue.LESS_THAN, input, "start");
  if (typeof value !== "undefined") {
    return {
      value,
      operator: FilterComparisonOperator.LESS_THAN
    };
  }
  value = matchOperator(FilterInputOperatorValue.MORE_THAN_EQUAL, input, "start");
  if (typeof value !== "undefined") {
    return {
      value,
      operator: FilterComparisonOperator.GREATER_THAN_EQUAL
    };
  }
  value = matchOperator(FilterInputOperatorValue.MORE_THAN, input, "start");
  if (typeof value !== "undefined") {
    return {
      value,
      operator: FilterComparisonOperator.GREATER_THAN
    };
  }
  return {
    value: input,
    operator: negation ? FilterComparisonOperator.NOT_EQUAL : FilterComparisonOperator.EQUAL
  };
}

function transformFiltersParseOutputElement(element) {
  if (hasOwnProperty(element, "path") && (typeof element.path === "undefined" || element.path === null)) {
    delete element.path;
  }
  if (element.operator) {
    return element;
  }
  if (typeof element.value === "string") {
    element = {
      ...element,
      ...parseFilterValue(element.value)
    };
  } else {
    element.operator = FilterComparisonOperator.EQUAL;
  }
  element.value = transformFilterValue(element.value);
  return element;
}
function buildDefaultFiltersParseOutput(options, input) {
  const inputKeys = Object.keys(input || {});
  if (!options.defaultByElement && inputKeys.length > 0) {
    return Object.values(input);
  }
  if (options.default) {
    const flatten = flattenNestedObject(options.default);
    const keys = Object.keys(flatten);
    const output = [];
    for (let i = 0; i < keys.length; i++) {
      const fieldDetails = getFieldDetails(keys[i]);
      if (options.defaultByElement && inputKeys.length > 0) {
        const fieldWithAlias = buildFieldWithPath(fieldDetails);
        if (hasOwnProperty(input, fieldWithAlias)) {
          continue;
        }
      }
      if (options.defaultByElement || inputKeys.length === 0) {
        let path;
        if (fieldDetails.path) {
          path = fieldDetails.path;
        } else if (options.defaultPath) {
          path = options.defaultPath;
        }
        output.push(transformFiltersParseOutputElement({
          ...path ? { path } : {},
          key: fieldDetails.name,
          value: flatten[keys[i]]
        }));
      }
    }
    return input ? [...Object.values(input), ...output] : output;
  }
  return input ? Object.values(input) : [];
}
function parseQueryFilters(data, options) {
  options = options || {};
  options.mapping = options.mapping || {};
  options.relations = options.relations || [];
  if (typeof options.allowed !== "undefined") {
    options.allowed = flattenParseAllowedOption(options.allowed);
    if (options.allowed.length === 0) {
      return buildDefaultFiltersParseOutput(options);
    }
  }
  if (typeof data !== "object" || data === null) {
    return buildDefaultFiltersParseOutput(options);
  }
  const { length } = Object.keys(data);
  if (length === 0) {
    return buildDefaultFiltersParseOutput(options);
  }
  if ((typeof options.allowed === "undefined" || options.allowed.length === 0) && options.default) {
    const flatten = flattenNestedObject(options.default);
    options.allowed = Object.keys(flatten);
  }
  const items = {};
  const keys = Object.keys(data);
  for (let i = 0; i < keys.length; i++) {
    if (!hasOwnProperty(data, keys[i])) {
      continue;
    }
    const value = data[keys[i]];
    if (typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean" && typeof value !== "undefined" && value !== null && !Array.isArray(value)) {
      continue;
    }
    keys[i] = applyMapping(keys[i], options.mapping);
    const fieldDetails = getFieldDetails(keys[i]);
    if (typeof options.allowed === "undefined" && !isValidFieldName(fieldDetails.name)) {
      continue;
    }
    if (!isFieldPathAllowedByRelations(fieldDetails, options.relations) && !isFieldNonRelational(fieldDetails)) {
      continue;
    }
    const fullKey = buildFieldWithPath(fieldDetails);
    if (options.allowed && !isPathCoveredByParseAllowedOption(options.allowed, [keys[i], fullKey])) {
      continue;
    }
    const filter = transformFiltersParseOutputElement({
      key: fieldDetails.name,
      value
    });
    if (options.validate) {
      if (Array.isArray(filter.value)) {
        const output = [];
        for (let j = 0; j < filter.value.length; j++) {
          if (options.validate(filter.key, filter.value[j])) {
            output.push(filter.value[j]);
          }
        }
        filter.value = output;
        if (filter.value.length === 0) {
          continue;
        }
      } else if (!options.validate(filter.key, filter.value)) {
        continue;
      }
    }
    if (typeof filter.value === "string" && filter.value.length === 0) {
      continue;
    }
    if (Array.isArray(filter.value) && filter.value.length === 0) {
      continue;
    }
    if (fieldDetails.path || options.defaultPath) {
      filter.path = fieldDetails.path || options.defaultPath;
    }
    items[fullKey] = filter;
  }
  return buildDefaultFiltersParseOutput(options, items);
}

function mergeQueryPagination(target, source) {
  return smob.merge({}, target || {}, source || {});
}

function finalizePagination(data, options) {
  if (typeof options.maxLimit !== "undefined") {
    if (typeof data.limit === "undefined" || data.limit > options.maxLimit) {
      data.limit = options.maxLimit;
    }
  }
  if (typeof data.limit !== "undefined" && typeof data.offset === "undefined") {
    data.offset = 0;
  }
  return data;
}
function parseQueryPagination(data, options) {
  options = options || {};
  const pagination = {};
  const prototype = Object.prototype.toString.call(data);
  if (prototype !== "[object Object]") {
    return finalizePagination(pagination, options);
  }
  let { limit, offset } = data;
  if (typeof limit !== "undefined") {
    limit = parseInt(limit, 10);
    if (!Number.isNaN(limit) && limit > 0) {
      pagination.limit = limit;
    }
  }
  if (typeof offset !== "undefined") {
    offset = parseInt(offset, 10);
    if (!Number.isNaN(offset) && offset >= 0) {
      pagination.offset = offset;
    }
  }
  return finalizePagination(pagination, options);
}

function buildQueryRelations(input) {
  if (typeof input === "undefined") {
    return input;
  }
  return flattenToKeyPathArray(input);
}
function mergeQueryRelations(target, source) {
  return smob.mergeArrays(target || [], source || [], true);
}

function includeParents(data) {
  for (let i = 0; i < data.length; i++) {
    const parts = data[i].split(".");
    while (parts.length > 0) {
      parts.pop();
      if (parts.length > 0) {
        const value = parts.join(".");
        if (data.indexOf(value) === -1) {
          data.unshift(value);
        }
      }
    }
  }
  return data;
}

function isValidRelationPath(input) {
  return /^[a-zA-Z0-9_-]+([.]*[a-zA-Z0-9_-])*$/gu.test(input);
}

function parseQueryRelations(data, options) {
  options = options || {};
  if (Array.isArray(options.allowed) && options.allowed.length === 0) {
    return [];
  }
  options.mapping = options.mapping || {};
  options.pathMapping = options.pathMapping || {};
  if (typeof options.includeParents === "undefined") {
    options.includeParents = true;
  }
  let items = [];
  const prototype = Object.prototype.toString.call(data);
  if (prototype !== "[object Array]" && prototype !== "[object String]") {
    return [];
  }
  if (prototype === "[object String]") {
    items = data.split(",");
  }
  if (prototype === "[object Array]") {
    items = data.filter((el) => typeof el === "string");
  }
  if (items.length === 0) {
    return [];
  }
  const mappingKeys = Object.keys(options.mapping);
  if (mappingKeys.length > 0) {
    for (let i = 0; i < items.length; i++) {
      items[i] = applyMapping(items[i], options.mapping);
    }
  }
  if (options.allowed) {
    items = items.filter((item) => isPathCoveredByParseAllowedOption(options.allowed, item));
  } else {
    items = items.filter((item) => isValidRelationPath(item));
  }
  if (options.includeParents) {
    if (Array.isArray(options.includeParents)) {
      const parentIncludes = items.filter(
        (item) => item.includes(".") && options.includeParents.filter((parent) => item.startsWith(parent)).length > 0
      );
      items.unshift(...includeParents(parentIncludes));
    } else {
      items = includeParents(items);
    }
  }
  items = Array.from(new Set(items));
  return items.map((key) => {
    const parts = key.split(".");
    let value;
    if (options.pathMapping && hasOwnProperty(options.pathMapping, key)) {
      value = options.pathMapping[key];
    } else {
      value = parts.pop();
    }
    return {
      key,
      value
    };
  });
}

var SortDirection = /* @__PURE__ */ ((SortDirection2) => {
  SortDirection2["ASC"] = "ASC";
  SortDirection2["DESC"] = "DESC";
  return SortDirection2;
})(SortDirection || {});

function buildQuerySort(data) {
  if (typeof data === "undefined") {
    return [];
  }
  if (typeof data === "string") {
    return [data];
  }
  return flattenToKeyPathArray(data, {
    transformer: (input, output, path) => {
      if (typeof input === "string" && path && (input === SortDirection.ASC || input === SortDirection.DESC)) {
        if (input === SortDirection.DESC) {
          output.push(`-${path}`);
        } else {
          output.push(path);
        }
        return true;
      }
      return void 0;
    }
  });
}
function mergeQuerySort(target, source) {
  return smob.mergeArrays(target || [], source || [], true);
}

function parseSortValue(value) {
  let direction = SortDirection.ASC;
  if (value.substring(0, 1) === "-") {
    direction = SortDirection.DESC;
    value = value.substring(1);
  }
  return {
    direction,
    value
  };
}

function isMultiDimensionalArray(arr) {
  if (!Array.isArray(arr)) {
    return false;
  }
  return arr.length > 0 && Array.isArray(arr[0]);
}
function buildDefaultSortParseOutput(options) {
  if (options.default) {
    const output = [];
    const flatten = flattenNestedObject(options.default);
    const keys = Object.keys(flatten);
    for (let i = 0; i < keys.length; i++) {
      const fieldDetails = getFieldDetails(keys[i]);
      let path;
      if (fieldDetails.path) {
        path = fieldDetails.path;
      } else if (options.defaultPath) {
        path = options.defaultPath;
      }
      output.push({
        key: fieldDetails.name,
        ...path ? { path } : {},
        value: flatten[keys[i]]
      });
    }
    return output;
  }
  return [];
}
function parseQuerySort(data, options) {
  options = options || {};
  if (typeof options.allowed !== "undefined") {
    const allowed = flattenParseAllowedOption(options.allowed);
    if (allowed.length === 0) {
      return buildDefaultSortParseOutput(options);
    }
  }
  options.mapping = options.mapping || {};
  const prototype = Object.prototype.toString.call(data);
  if (prototype !== "[object String]" && prototype !== "[object Array]" && prototype !== "[object Object]") {
    return buildDefaultSortParseOutput(options);
  }
  if (typeof options.allowed === "undefined" && options.default) {
    const flatten = flattenNestedObject(options.default);
    options.allowed = Object.keys(flatten);
  }
  let parts = [];
  if (typeof data === "string") {
    parts = data.split(",");
  }
  if (Array.isArray(data)) {
    parts = data.filter((item) => typeof item === "string");
  }
  if (typeof data === "object" && data !== null) {
    const keys = Object.keys(data);
    for (let i = 0; i < keys.length; i++) {
      if (!hasOwnProperty(data, keys[i]) || typeof keys[i] !== "string" || typeof data[keys[i]] !== "string")
        continue;
      const fieldPrefix = data[keys[i]].toLowerCase() === "desc" ? "-" : "";
      parts.push(fieldPrefix + keys[i]);
    }
  }
  const items = {};
  let matched = false;
  for (let i = 0; i < parts.length; i++) {
    const { value, direction } = parseSortValue(parts[i]);
    parts[i] = value;
    const key = applyMapping(parts[i], options.mapping);
    const fieldDetails = getFieldDetails(key);
    if (typeof options.allowed === "undefined" && !isValidFieldName(fieldDetails.name)) {
      continue;
    }
    if (!isFieldPathAllowedByRelations(fieldDetails, options.relations) && !isFieldNonRelational(fieldDetails)) {
      continue;
    }
    const keyWithAlias = buildFieldWithPath(fieldDetails);
    if (typeof options.allowed !== "undefined" && !isMultiDimensionalArray(options.allowed) && !isPathCoveredByParseAllowedOption(options.allowed, [key, keyWithAlias])) {
      continue;
    }
    matched = true;
    let path;
    if (fieldDetails.path) {
      path = fieldDetails.path;
    } else if (options.defaultPath) {
      path = options.defaultPath;
    }
    items[keyWithAlias] = {
      key: fieldDetails.name,
      ...path ? { path } : {},
      value: direction
    };
  }
  if (!matched) {
    return buildDefaultSortParseOutput(options);
  }
  if (isMultiDimensionalArray(options.allowed)) {
    outerLoop:
      for (let i = 0; i < options.allowed.length; i++) {
        const temp = [];
        const keyPaths = flattenParseAllowedOption(options.allowed[i]);
        for (let j = 0; j < keyPaths.length; j++) {
          let keyWithAlias = keyPaths[j];
          let key;
          const parts2 = keyWithAlias.split(".");
          if (parts2.length > 1) {
            key = parts2.pop();
          } else {
            key = keyWithAlias;
            keyWithAlias = buildKeyPath(key, options.defaultPath);
          }
          if (hasOwnProperty(items, key) || hasOwnProperty(items, keyWithAlias)) {
            const item = hasOwnProperty(items, key) ? items[key] : items[keyWithAlias];
            temp.push(item);
          } else {
            continue outerLoop;
          }
        }
        return temp;
      }
    return [];
  }
  return Object.values(items);
}

function buildQuery(input) {
  if (typeof input === "undefined" || input === null) {
    return "";
  }
  const query = {};
  if (typeof input[Parameter.FIELDS] !== "undefined" || typeof input[URLParameter.FIELDS] !== "undefined") {
    query[URLParameter.FIELDS] = mergeQueryFields(
      buildQueryFields(input[Parameter.FIELDS]),
      buildQueryFields(input[URLParameter.FIELDS])
    );
  }
  if (typeof input[Parameter.FILTERS] !== "undefined" || typeof input[URLParameter.FILTERS] !== "undefined") {
    query[URLParameter.FILTERS] = mergeQueryFilters(
      buildQueryFilters(input[Parameter.FILTERS]),
      buildQueryFilters(input[URLParameter.FILTERS])
    );
  }
  if (typeof input[Parameter.PAGINATION] !== "undefined" || typeof input[URLParameter.PAGINATION] !== "undefined") {
    query[URLParameter.PAGINATION] = mergeQueryPagination(
      input[Parameter.PAGINATION],
      input[URLParameter.PAGINATION]
    );
  }
  if (typeof input[Parameter.RELATIONS] !== "undefined" || typeof input[URLParameter.RELATIONS] !== "undefined") {
    query[URLParameter.RELATIONS] = mergeQueryRelations(
      buildQueryRelations(input[Parameter.RELATIONS]),
      buildQueryRelations(input[URLParameter.RELATIONS])
    );
  }
  if (typeof input[Parameter.SORT] !== "undefined" || typeof input[URLParameter.SORT] !== "undefined") {
    query[URLParameter.SORT] = mergeQuerySort(
      buildQuerySort(input[Parameter.SORT]),
      buildQuerySort(input[URLParameter.SORT])
    );
  }
  return buildURLQueryString(query);
}

function parseQueryParameter(key, data, options, relations) {
  switch (key) {
    case Parameter.FIELDS:
    case URLParameter.FIELDS:
      return parseQueryFields(
        data,
        {
          ...invalidToEmptyObject(options),
          ...relations ? { relations } : {}
        }
      );
    case Parameter.FILTERS:
    case URLParameter.FILTERS:
      return parseQueryFilters(
        data,
        {
          ...invalidToEmptyObject(options),
          ...relations ? { relations } : {}
        }
      );
    case Parameter.PAGINATION:
    case URLParameter.PAGINATION:
      return parseQueryPagination(
        data,
        {
          ...invalidToEmptyObject(options)
        }
      );
    case Parameter.RELATIONS:
    case URLParameter.RELATIONS:
      return parseQueryRelations(
        data,
        {
          ...invalidToEmptyObject(options)
        }
      );
    default:
      return parseQuerySort(
        data,
        {
          ...invalidToEmptyObject(options),
          ...relations ? { relations } : {}
        }
      );
  }
}
function invalidToEmptyObject(value) {
  return typeof value === "boolean" || typeof value === "undefined" ? {} : value;
}

function buildQueryParameterOptions(input) {
  if (typeof input === "boolean") {
    return {};
  }
  return input;
}
function isQueryParameterEnabled(input) {
  if (typeof input === "boolean") {
    return input;
  }
  return true;
}

function parseQuery(input, options) {
  options = options || {};
  const mergeWithGlobalOptions = (data) => {
    if (typeof data !== "undefined") {
      if (options.defaultPath) {
        data.defaultPath = options.defaultPath;
      }
    }
    return data;
  };
  const output = {};
  if (options.defaultPath) {
    output.defaultPath = options.defaultPath;
  }
  let relations;
  const keys = [
    Parameter.RELATIONS,
    Parameter.FIELDS,
    Parameter.FILTERS,
    Parameter.PAGINATION,
    Parameter.SORT
  ];
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    switch (key) {
      case Parameter.RELATIONS: {
        const value = input[Parameter.RELATIONS] || input[URLParameter.RELATIONS];
        if (value && isQueryParameterEnabled(options[Parameter.RELATIONS])) {
          relations = parseQueryParameter(
            key,
            value,
            buildQueryParameterOptions(options[Parameter.RELATIONS])
          );
          output[Parameter.RELATIONS] = relations;
        }
        break;
      }
      case Parameter.FIELDS: {
        const value = input[Parameter.FIELDS] || input[URLParameter.FIELDS];
        if (value && isQueryParameterEnabled(options[Parameter.FIELDS])) {
          output[Parameter.FIELDS] = parseQueryParameter(
            key,
            value,
            mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FIELDS])),
            relations
          );
        }
        break;
      }
      case Parameter.FILTERS: {
        const value = input[Parameter.FILTERS] || input[URLParameter.FILTERS];
        if (value && isQueryParameterEnabled(options[Parameter.FILTERS])) {
          output[Parameter.FILTERS] = parseQueryParameter(
            key,
            value,
            mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FILTERS])),
            relations
          );
        }
        break;
      }
      case Parameter.PAGINATION: {
        const value = input[Parameter.PAGINATION] || input[URLParameter.PAGINATION];
        if (value && isQueryParameterEnabled(options[Parameter.PAGINATION])) {
          output[Parameter.PAGINATION] = parseQueryParameter(
            key,
            value,
            buildQueryParameterOptions(options[Parameter.PAGINATION]),
            relations
          );
        }
        break;
      }
      case Parameter.SORT: {
        const value = input[Parameter.SORT] || input[URLParameter.SORT];
        if (value && isQueryParameterEnabled(options[Parameter.SORT])) {
          output[Parameter.SORT] = parseQueryParameter(
            key,
            value,
            mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.SORT])),
            relations
          );
        }
        break;
      }
    }
  }
  return output;
}

exports.DEFAULT_ID = DEFAULT_ID;
exports.FieldOperator = FieldOperator;
exports.FilterComparisonOperator = FilterComparisonOperator;
exports.FilterInputOperatorValue = FilterInputOperatorValue;
exports.Parameter = Parameter;
exports.SortDirection = SortDirection;
exports.URLParameter = URLParameter;
exports.buildFieldDomainRecords = buildFieldDomainRecords;
exports.buildQuery = buildQuery;
exports.buildQueryFields = buildQueryFields;
exports.buildQueryFilters = buildQueryFilters;
exports.buildQueryParameterOptions = buildQueryParameterOptions;
exports.buildQueryRelations = buildQueryRelations;
exports.buildQuerySort = buildQuerySort;
exports.flattenParseAllowedOption = flattenParseAllowedOption;
exports.isPathCoveredByParseAllowedOption = isPathCoveredByParseAllowedOption;
exports.isQueryParameterEnabled = isQueryParameterEnabled;
exports.isValidFieldName = isValidFieldName;
exports.mergeQueryFields = mergeQueryFields;
exports.mergeQueryFilters = mergeQueryFilters;
exports.mergeQueryPagination = mergeQueryPagination;
exports.mergeQueryRelations = mergeQueryRelations;
exports.mergeQuerySort = mergeQuerySort;
exports.parseFieldsInput = parseFieldsInput;
exports.parseFilterValue = parseFilterValue;
exports.parseQuery = parseQuery;
exports.parseQueryFields = parseQueryFields;
exports.parseQueryFilters = parseQueryFilters;
exports.parseQueryPagination = parseQueryPagination;
exports.parseQueryParameter = parseQueryParameter;
exports.parseQueryRelations = parseQueryRelations;
exports.parseQuerySort = parseQuerySort;
exports.removeFieldInputOperator = removeFieldInputOperator;
exports.transformFieldsInput = transformFieldsInput;
exports.transformFilterValue = transformFilterValue;
